
完整的路径: D:\JS\chrome_extension\aiTools\background.js
内容:
// 监听快捷键
chrome.commands.onCommand.addListener((command) => {
  if (command === "insert-text") {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      // 检查是否有错误
      if (chrome.runtime.lastError) {
        console.error("查询标签失败:", chrome.runtime.lastError);
        return;
      }
      // 检查是否找到活动标签
      if (tabs.length > 0) {
        chrome.tabs.sendMessage(tabs[0].id, { action: "insertText" }, (response) => {
          if (chrome.runtime.lastError) {
            console.error("发送消息失败:", chrome.runtime.lastError);
          }
        });
      } else {
        console.error("未找到活动标签");
      }
    });
  }
});

// 下载逻辑保持不变
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === "download") {
    chrome.downloads.download({
      url: request.url,
      saveAs: false
    }, (downloadId) => {
      if (chrome.runtime.lastError) {
        console.error("下载失败:", chrome.runtime.lastError);
        sendResponse({ success: false });
      } else {
        sendResponse({ success: true });
      }
    });
    return true; // 保持消息通道开放
  }
});

完整的路径: D:\JS\chrome_extension\aiTools\gemini_auto_save.js
内容:

(function () {
  "use strict";

  // --- 配置 ---
  const SAVE_BUTTON_SELECTOR = 'button[aria-label="Save prompt"]'; // **修正：这是保存按钮的选择器**
  // 备选选择器 (如果上面的失效): 'button[data-test-manual-save="outside"]' 或包含 'save-button' 类的按钮
  const CLICK_INTERVAL_MS = 30000; // 30秒
  // --- 结束配置 ---

  let intervalId = null; // 用于存储 setInterval 的 ID，方便之后清除

  /**
   * 检查按钮是否准备好被点击 (存在、未禁用、可见)
   * @param {Element} buttonElement - 要检查的按钮元素
   * @returns {boolean} - 如果按钮可点击则返回 true
   */
  function isButtonReadyToClick(buttonElement) {
    if (!buttonElement) {
      // console.log(`Log: Button with selector "${SAVE_BUTTON_SELECTOR}" not found in DOM yet.`);
      return false; // 按钮不存在
    }
    // 检查按钮是否被禁用
    if (buttonElement.disabled) {
      console.log(`Log: SAVE button (${SAVE_BUTTON_SELECTOR}) found, but it is disabled.`);
      return false;
    }
    // 检查按钮是否可见
    const rect = buttonElement.getBoundingClientRect();
    if (
      buttonElement.offsetParent === null || // 元素或其祖先 display: none
      rect.width === 0 ||                   // 宽度为0
      rect.height === 0                     // 高度为0
    ) {
      console.log(`Log: SAVE button (${SAVE_BUTTON_SELECTOR}) found, but it is not visible (offsetParent is null or dimensions are zero).`);
      return false;
    }
    // 你还可以添加其他条件，例如检查特定的class来判断是否可点击
    // if (buttonElement.classList.contains('some-inactive-class')) {
    //     console.log('Log: SAVE button found, but has an inactive class.');
    //     return false;
    // }
    return true;
  }

  /**
   * 尝试查找并点击保存按钮
   */
  function attemptClick() {
    console.log(`Log: Attempting to find SAVE button with selector: "${SAVE_BUTTON_SELECTOR}"`);
    const saveButton = document.querySelector(SAVE_BUTTON_SELECTOR);

    if (isButtonReadyToClick(saveButton)) {
      console.log(`Log: SAVE button (${SAVE_BUTTON_SELECTOR}) found and is clickable. Clicking now!`);
      saveButton.click();
      console.log(`Log: SAVE button (${SAVE_BUTTON_SELECTOR}) successfully clicked.`); // **点击后增加的日志**

      // 可选：如果点击后希望停止定时器，可以在这里清除
      // stopAutoClick();
      // console.log('Log: SAVE button clicked. Auto-clicker stopped.');
    } else if (saveButton) {
      // 按钮存在但不可点击，isButtonReadyToClick 内部已经打印了原因
      // console.log(`Log: SAVE button (${SAVE_BUTTON_SELECTOR}) found, but it's not in a clickable state (e.g., disabled or not visible). Check previous logs from isButtonReadyToClick.`);
    } else {
      // 按钮未找到，isButtonReadyToClick 返回 false 前，此日志更早出现
      console.log(`Log: SAVE button with selector "${SAVE_BUTTON_SELECTOR}" was NOT found in the DOM.`);
    }
  }

  /**
   * 启动自动点击定时器
   */
  function startAutoClick() {
    if (intervalId !== null) {
      console.log("Log: Auto-clicker for SAVE button is already running.");
      return;
    }
    console.log(
      `Log: Starting auto-clicker for SAVE button. Will attempt to click every ${
        CLICK_INTERVAL_MS / 1000
      } seconds.`
    );
    // 立即执行一次，然后设置定时器
    attemptClick(); // 确保启动时立即尝试一次
    intervalId = setInterval(attemptClick, CLICK_INTERVAL_MS);
  }

  /**
   * 停止自动点击定时器
   */
  function stopAutoClick() {
    if (intervalId !== null) {
      clearInterval(intervalId);
      intervalId = null;
      console.log("Log: Auto-clicker for SAVE button stopped.");
    } else {
      console.log("Log: Auto-clicker for SAVE button is not running (cannot stop).");
    }
  }

  // --- 脚本启动逻辑 ---
  // 确保页面加载完毕后再启动，避免元素还未渲染
  if (document.readyState === "loading") {
    console.log("Log: Document is loading. Waiting for DOMContentLoaded.");
    document.addEventListener("DOMContentLoaded", function() {
        console.log("Log: DOMContentLoaded event fired. Starting auto-clicker.");
        startAutoClick();
    });
  } else {
    console.log("Log: Document already loaded. Starting auto-clicker immediately.");
    startAutoClick();
  }

  // 2. 或者，你可以暴露函数到 window 对象，以便在控制台手动控制 (用于测试和调试)
  // window.geminiAutoSaver = { start: startAutoClick, stop: stopAutoClick };
  // console.log('Log: To control from console, use: window.geminiAutoSaver.start() and window.geminiAutoSaver.stop()');

})();

完整的路径: D:\JS\chrome_extension\aiTools\grok_content.js
内容:
(function () {


  // 现有功能：点击专注模式按钮
  function clickFocusButton() {
    const focusButton =
      document.querySelector('button[aria-label="专注模式"]') ||
      document.querySelector('button.r-1phboty.r-10v3vxq');
    if (focusButton) {
      focusButton.click();
      console.log('专注模式按钮已点击');
      return true;
    } else {
      console.log('专注模式按钮未找到');
      return false;
    }
  }

  // 现有功能：调整输入框
  function adjustInputBox() {
    const textarea = document.querySelector('textarea.r-30o5oe');
    if (textarea) {
      textarea.style.height = '86px';
      textarea.focus();
      console.log('输入框高度已调整为 86px 并聚焦');
      return true;
    } else {
      console.log('输入框未找到');
      return false;
    }
  }

   
   

  // 初始化现有功能
  let focusButtonClicked = clickFocusButton();
  if (focusButtonClicked) {
    adjustInputBox();
  }

  // 增强 MutationObserver，监控复制按钮和回答内容的动态加载
  const observer = new MutationObserver((mutations, obs) => {
    // 检查专注模式和输入框
    if (!focusButtonClicked && clickFocusButton()) {
      focusButtonClicked = true;
      adjustInputBox();
    } else if (focusButtonClicked && adjustInputBox()) {
      // 仅在完成专注模式和输入框调整后停止监控这两部分
      console.log('专注模式和输入框调整完成');
    }

    

  });

  // 监控整个页面，捕获动态加载的元素
  const container = document.querySelector('.css-175oi2r') || document.body;
  observer.observe(container, { childList: true, subtree: true });

  // 10 秒后停止监控，避免性能问题
  setTimeout(() => {
    observer.disconnect();
    console.log('停止监控，未完成所有操作');
  }, 10000);
})();

完整的路径: D:\JS\chrome_extension\aiTools\grok_insert_text.js
内容:
// 处理 https://grok.com/* 的文字插入逻辑，
// 响应 background.js 发送的 insertText 消息。



(function () {
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      if (message.action === 'insertText') {
        const dialogBox = document.querySelector('textarea') || document.querySelector("input[type='text']");
        if (dialogBox) {
          const textToInsert = '你是一名计算机专家，编程高手。\n我是一名普通程序员。请用中文来解释。\n\n';
          dialogBox.value = textToInsert;
          const inputEvent = new Event('input', { bubbles: true });
          dialogBox.dispatchEvent(inputEvent);
          console.log('已插入预设文字');
        } else {
          console.log('未找到对话框元素');
        }
      }
    });
  })();

完整的路径: D:\JS\chrome_extension\aiTools\index.js
内容:
console.log('Happy developing ✨')


完整的路径: D:\JS\chrome_extension\aiTools\main.css
内容: 此文件为空

完整的路径: D:\JS\chrome_extension\aiTools\manifest.json
内容:
{
  "manifest_version": 3,
  "name": "aiTools",
  "description": "A toolbox for automating actions on specific websites",
  "version": "1.0",
  "permissions": [
    "storage",
    "activeTab",
    "scripting",
    "downloads",
    "tabs",
    "clipboardWrite"
  ],
  "commands": {
    "insert-text": {
      "suggested_key": {
        "default": "Ctrl+Q",
        "mac": "Command+Shift+G"
      },
      "description": "在 grok.com 的对话框中输入预设文字"
    }
  },
  "background": {
    "service_worker": "background.js"
  },

  "icons": {
    "16": "/images/icon16_active.png",
    "48": "/images/icon48_active.png",
    "128": "/images/icon128_active.png"
  },

  "action": {
    "default_icon": {
      "16": "/images/icon16_active.png",
      "48": "/images/icon48_active.png",
      "128": "/images/icon128_active.png"
    },
    "default_popup": "popup.html"
  },

  "content_scripts": [
    {
      "matches": ["https://x.com/i/grok"],
      "js": ["turndown.js", "grok_content.js"]
    },
    {
      "matches": ["https://i.pinimg.com/*"],
      "js": ["pinterest_content.js"]
    },
    {
      "matches": ["https://grok.com/*"],
      "js": ["grok_insert_text.js"]
    },
    {
      "matches": ["<all_urls>"],
      "js": ["scroll_control.js"]
    },
    {
      "matches": ["https://aistudio.google.com/prompts/*"],
      "js": ["gemini_auto_save.js"]
    },
    {
      "matches": ["https://medium.com/*"],
      "js": ["medium_content.js"]
    }
  ]
}


完整的路径: D:\JS\chrome_extension\aiTools\medium_content.js
内容:
// 处理 https://medium.com/* 的文本选择菜单隐藏逻辑

(function () {
  "use strict";

  // 隐藏Medium文本选择菜单的CSS样式
  function addHideMenuStyles() {
    const style = document.createElement("style");
    style.id = "medium-hide-selection-menu";
    style.textContent = `
      /* 隐藏Medium文本选择弹出菜单 */
      div[class*="eo o ady ff adz aea aeb"],
      div[data-popper-reference-hidden],
      div[data-popper-escaped],
      div[data-popper-placement] {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
      }
      
      /* 更具体的选择器，针对包含强调、回应、分享、私人笔记按钮的容器 */
      div[tabindex="-1"] > div[style*="position: absolute"] {
        display: none !important;
      }
      
      /* 隐藏包含这些按钮文本的容器 */
      div:has(p:contains("强调")),
      div:has(p:contains("回应")),
      div:has(p:contains("分享")),
      div:has(p:contains("私人笔记")) {
        display: none !important;
      }
    `;

    // 将样式添加到head中
    if (document.head) {
      document.head.appendChild(style);
      console.log("Medium文本选择菜单隐藏样式已添加");
    } else {
      // 如果head还没准备好，等待DOM加载
      document.addEventListener("DOMContentLoaded", () => {
        document.head.appendChild(style);
        console.log("Medium文本选择菜单隐藏样式已添加 (DOMContentLoaded)");
      });
    }
  }

  // 使用MutationObserver监控动态添加的菜单元素
  function observeAndHideMenus() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            // 检查是否是文本选择菜单容器
            if (
              node.classList &&
              (node.classList.contains("eo") ||
                node.hasAttribute("data-popper-reference-hidden") ||
                node.hasAttribute("data-popper-escaped") ||
                node.hasAttribute("data-popper-placement"))
            ) {
              node.style.display = "none";
              node.style.visibility = "hidden";
              node.style.opacity = "0";
              node.style.pointerEvents = "none";
              console.log("动态隐藏了Medium文本选择菜单");
            }

            // 检查子元素中是否包含菜单
            const menuElements =
              node.querySelectorAll &&
              node.querySelectorAll(
                [
                  'div[class*="eo o ady ff adz aea aeb"]',
                  "div[data-popper-reference-hidden]",
                  "div[data-popper-escaped]",
                  "div[data-popper-placement]",
                ].join(",")
              );

            if (menuElements && menuElements.length > 0) {
              menuElements.forEach((menu) => {
                menu.style.display = "none";
                menu.style.visibility = "hidden";
                menu.style.opacity = "0";
                menu.style.pointerEvents = "none";
              });
              console.log(
                `动态隐藏了${menuElements.length}个Medium文本选择菜单元素`
              );
            }
          }
        });
      });
    });

    // 开始观察
    observer.observe(document.body || document.documentElement, {
      childList: true,
      subtree: true,
    });

    console.log("Medium文本选择菜单监控已启动");

    // 10秒后停止监控以避免性能问题
    setTimeout(() => {
      observer.disconnect();
      console.log("Medium文本选择菜单监控已停止");
    }, 10000);
  }

  // 立即隐藏已存在的菜单元素
  function hideExistingMenus() {
    const selectors = [
      'div[class*="eo o ady ff adz aea aeb"]',
      "div[data-popper-reference-hidden]",
      "div[data-popper-escaped]",
      "div[data-popper-placement]",
      'div[tabindex="-1"] > div[style*="position: absolute"]',
    ];

    selectors.forEach((selector) => {
      const elements = document.querySelectorAll(selector);
      elements.forEach((element) => {
        element.style.display = "none";
        element.style.visibility = "hidden";
        element.style.opacity = "0";
        element.style.pointerEvents = "none";
      });
      if (elements.length > 0) {
        console.log(
          `隐藏了${elements.length}个现有的Medium文本选择菜单元素 (${selector})`
        );
      }
    });
  }

  // 初始化函数
  function init() {
    // 添加CSS样式
    addHideMenuStyles();

    // 隐藏现有菜单
    hideExistingMenus();

    // 开始监控新菜单
    observeAndHideMenus();

    console.log("Medium文本选择菜单隐藏功能已初始化");
  }

  // 根据页面加载状态执行初始化
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }

  // 页面完全加载后再次检查
  window.addEventListener("load", () => {
    setTimeout(() => {
      hideExistingMenus();
      console.log("页面加载完成后再次隐藏Medium文本选择菜单");
    }, 1000);
  });
})();


完整的路径: D:\JS\chrome_extension\aiTools\package.json
内容:
{
  "name": "aiTools",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "private": true
}


完整的路径: D:\JS\chrome_extension\aiTools\pinterest_content.js
内容:
// 处理 https://i.pinimg.com/* 的 URL 修改和图片下载逻辑。


(function () {
    let newUrl = window.location.href;
    let urlChanged = false;
    if (newUrl.includes('/736x/')) {
      newUrl = newUrl.replace('/736x/', '/originals/');
      urlChanged = true;
    } else if (newUrl.includes('/1200x/')) {
      newUrl = newUrl.replace('/1200x/', '/originals/');
      urlChanged = true;
    }
  
    if (urlChanged) {
      window.location.replace(newUrl);
    }
  
    if (newUrl.includes('/originals/')) {
      function triggerDownload() {
        const img = document.querySelector('img');
        if (img && img.src) {
          console.log('找到图片，URL:', img.src);
          chrome.runtime.sendMessage(
            {
              action: 'download',
              url: img.src
            },
            (response) => {
              if (response && response.success) {
                console.log('图片下载已触发');
              } else {
                console.log('图片下载失败:', response ? response.error : '无响应');
              }
            }
          );
          return true;
        } else {
          console.log('图片元素未找到');
          return false;
        }
      }
  
      window.addEventListener('load', () => {
        if (triggerDownload()) {
          console.log('下载在 load 事件中触发');
        }
      });
  
      const observer = new MutationObserver((mutations, obs) => {
        if (triggerDownload()) {
          obs.disconnect();
          console.log('下载在 MutationObserver 中触发，停止监控');
        }
      });
  
      observer.observe(document.body, { childList: true, subtree: true });
  
      setTimeout(() => {
        observer.disconnect();
        console.log('停止监控图片，未触发下载');
      }, 5000);
    }
  })();

完整的路径: D:\JS\chrome_extension\aiTools\popup.html
内容:
<!DOCTYPE html>
 

<!-- 处理中文。 -->
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">

    <title>Auto Scroll Control</title>
    <style>
        body {
            width: 350px;
            padding: 10px;
            font-family: 'Microsoft YaHei', sans-serif;
            background-color: #f5f5f5;
        }

        .container {
            background-color: white;
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header img {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin-bottom: 10px;
        }

        h3 {
            color: #333;
            margin: 0;
            font-size: 18px;
        }

        .domain-info {
            color: #666;
            font-size: 14px;
            margin: 10px 0;
            padding: 8px;
            background-color: #f8f8f8;
            border-radius: 5px;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .scroll-btn {
            background-color: #4CAF50;
            color: white;
        }

        .scroll-btn:hover {
            background-color: #45a049;
        }

        .stop-btn {
            background-color: #f44336;
            color: white;
            grid-column: span 2;
        }

        .stop-btn:hover {
            background-color: #da190b;
        }

        .active {
            background-color: #2196F3;
        }

        .auto-refresh-btn {
            background-color: #9C27B0;
            color: white;
            grid-column: span 2;
        }

        .auto-refresh-btn:hover {
            background-color: #7B1FA2;
        }

        .auto-refresh-btn.active {
            background-color: #673AB7;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <img src="images/g1.png" alt="scroll-icon">
            <h3>自动滚动控制</h3>
        </div>
        
        <div class="domain-info">
            当前网站: <span id="currentDomain"></span>
        </div>

        <div class="button-group">
            <button id="normalSpeedBtn" class="scroll-btn">正常速度</button>
            <button id="doubleSpeedBtn" class="scroll-btn">2倍速度</button>
            <button id="fiveSpeedBtn" class="scroll-btn">5倍速度</button>
            <button id="autoRefreshBtn" class="auto-refresh-btn active">自动刷新: 开启</button>
            <button id="stopScrollButton" class="stop-btn">停止滚动</button>
        </div>
    </div>

    <script src="popup.js"></script>

</body>
</html>

完整的路径: D:\JS\chrome_extension\aiTools\popup.js
内容:
document.addEventListener('DOMContentLoaded', function () {
    const normalSpeedBtn = document.getElementById('normalSpeedBtn');
    const doubleSpeedBtn = document.getElementById('doubleSpeedBtn');
    const fiveSpeedBtn = document.getElementById('fiveSpeedBtn');
    const stopScrollButton = document.getElementById('stopScrollButton');
    const autoRefreshBtn = document.getElementById('autoRefreshBtn');
    const currentDomain = document.getElementById('currentDomain');

    let isAutoRefreshEnabled = true; // 默认开启自动刷新

    // 初始化自动刷新按钮状态
    autoRefreshBtn.textContent = '自动刷新: 开启';
    autoRefreshBtn.classList.add('active');

    // 检查当前标签页是否可以注入脚本
    function canInjectScript(tab) {
        // 检查是否是 chrome:// 开头的页面
        if (tab.url.startsWith('chrome://')) {
            return false;
        }
        // 检查是否是 chrome-extension:// 开头的页面
        if (tab.url.startsWith('chrome-extension://')) {
            return false;
        }
        // 检查是否是 file:// 开头的页面
        if (tab.url.startsWith('file://')) {
            return false;
        }
        return true;
    }

    // 获取当前标签页的域名
    chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
        if (tabs[0]) {
            const url = new URL(tabs[0].url);
            currentDomain.textContent = url.hostname;
            
            // 如果当前页面不允许注入脚本，禁用所有按钮
            if (!canInjectScript(tabs[0])) {
                [normalSpeedBtn, doubleSpeedBtn, fiveSpeedBtn, stopScrollButton, autoRefreshBtn].forEach(btn => {
                    btn.disabled = true;
                    btn.title = '当前页面不支持此功能';
                });
                currentDomain.textContent += ' (不支持)';
            }
        }
    });

    // 更新按钮状态
    function updateButtonStates(activeButton) {
        [normalSpeedBtn, doubleSpeedBtn, fiveSpeedBtn].forEach(btn => {
            btn.classList.remove('active');
        });
        if (activeButton) {
            activeButton.classList.add('active');
        }
    }

    // 发送滚动消息的通用函数
    function sendScrollMessage(speed, autoRefresh = false) {
        chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
            if (!tabs[0] || !canInjectScript(tabs[0])) {
                console.log('当前页面不支持此功能');
                return;
            }

            chrome.tabs.sendMessage(tabs[0].id, { 
                action: 'startScroll',
                speed: speed,
                autoRefresh: autoRefresh
            }).catch(error => {
                console.log('发送消息失败:', error);
                // 如果发送失败，重置按钮状态
                updateButtonStates(null);
                isAutoRefreshEnabled = true; // 重置为默认开启状态
                autoRefreshBtn.textContent = '自动刷新: 开启';
                autoRefreshBtn.classList.add('active');
            });
        });
    }

    // 更新自动刷新按钮状态
    function updateAutoRefreshButton() {
        isAutoRefreshEnabled = !isAutoRefreshEnabled;
        autoRefreshBtn.textContent = `自动刷新: ${isAutoRefreshEnabled ? '开启' : '关闭'}`;
        autoRefreshBtn.classList.toggle('active', isAutoRefreshEnabled);
        
        // 如果当前有滚动在进行，更新滚动状态
        if (document.querySelector('.scroll-btn.active')) {
            const activeButton = document.querySelector('.scroll-btn.active');
            let speed = 1;
            if (activeButton === doubleSpeedBtn) speed = 5;
            if (activeButton === fiveSpeedBtn) speed = 10;
            sendScrollMessage(speed, isAutoRefreshEnabled);
        }
    }

    // 自动刷新按钮点击事件
    autoRefreshBtn.addEventListener('click', updateAutoRefreshButton);

    // 正常速度滚动
    normalSpeedBtn.addEventListener('click', function () {
        sendScrollMessage(1, isAutoRefreshEnabled);
        updateButtonStates(normalSpeedBtn);
    });

    // 2倍速度滚动
    doubleSpeedBtn.addEventListener('click', function () {
        sendScrollMessage(5, isAutoRefreshEnabled);
        updateButtonStates(doubleSpeedBtn);
    });

    // 5倍速度滚动
    fiveSpeedBtn.addEventListener('click', function () {
        sendScrollMessage(10, isAutoRefreshEnabled);
        updateButtonStates(fiveSpeedBtn);
    });

    // 停止滚动
    stopScrollButton.addEventListener('click', function () {
        chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
            if (!tabs[0] || !canInjectScript(tabs[0])) {
                console.log('当前页面不支持此功能');
                return;
            }

            chrome.tabs.sendMessage(tabs[0].id, { 
                action: 'stopScroll',
                autoRefresh: false 
            }).catch(error => {
                console.log('发送消息失败:', error);
            }).finally(() => {
                // 无论消息是否发送成功，都重置UI状态
                updateButtonStates(null);
                isAutoRefreshEnabled = true; // 重置为默认开启状态
                autoRefreshBtn.textContent = '自动刷新: 开启';
                autoRefreshBtn.classList.add('active');
            });
        });
    });
});

完整的路径: D:\JS\chrome_extension\aiTools\resize_imamge.py
内容:
from PIL import Image

# 目的  调整图片大小。做 Chrome 插件的时候，需要用到图标。
# 先找2张图片

def resize_image(input_name, out_name, out_width, out_height):
    img = Image.open(input_name)
    out = img.resize((out_width, out_height))
    out.save(out_name)


def convert_to_grayscale(input_path: str, output_path: str):
    """
    将图片转换为灰度图像，并保存到指定路径。

    :param input_path: 输入图片的路径。
    :param output_path: 输出灰度图片的路径。
    """
    image = Image.open(input_path).convert("L")  # 转换为灰度模式
    image.save(output_path)
    print(f"灰度图片已保存至: {output_path}")



if __name__ == "__main__":
    # 1. 先准备一个图片 g1.png
    # 2. 调用函数
    convert_to_grayscale("g1.png", "g2.png")

    # 插件激活状态的图标
    input_image = "g1.png"
    for i in [16, 48, 128]:
        out_image = f"icon{i}_active.png"
        resize_image(input_image, out_image, i, i)


    # 默认转态下的图标
    input_image = "g2.png"
    for i in [16, 48, 128]:
        out_image = f"icon{i}.png"
        resize_image(input_image, out_image, i, i)




完整的路径: D:\JS\chrome_extension\aiTools\scroll_control.js
内容:
// 处理滚动控制逻辑，响应 popup.js 发送的 startScroll 和 stopScroll 消息。

(function () {
    let scrollInterval = null;
    let refreshInterval = null;
    let currentSpeed = 1; // 默认速度倍率
    let isAutoRefreshEnabled = false;
    let lastRefreshTime = Date.now();
    let shouldAutoScroll = false; // 新增：标记是否需要自动滚动

    // 保存滚动状态到 sessionStorage
    function saveScrollState(speed, autoRefresh) {
        sessionStorage.setItem('scrollState', JSON.stringify({
            speed: speed,
            autoRefresh: autoRefresh,
            timestamp: Date.now()
        }));
    }

    // 清除滚动状态
    function clearScrollState() {
        sessionStorage.removeItem('scrollState');
    }

    // 检查并恢复滚动状态
    function checkAndRestoreScrollState() {
        const savedState = sessionStorage.getItem('scrollState');
        if (savedState) {
            const state = JSON.parse(savedState);
            // 如果状态保存时间在5分钟内，则恢复滚动
            if (Date.now() - state.timestamp < 5 * 60 * 1000) {
                smoothAutoScroll(state.speed, state.autoRefresh);
            } else {
                clearScrollState();
            }
        }
    }

    function smoothAutoScroll(speed = 1, autoRefresh = false) {
        if (scrollInterval) {
            clearInterval(scrollInterval);
        }
        if (refreshInterval) {
            clearInterval(refreshInterval);
        }

        currentSpeed = speed;
        isAutoRefreshEnabled = autoRefresh;
        lastRefreshTime = Date.now();
        shouldAutoScroll = true; // 设置自动滚动标记
        saveScrollState(speed, autoRefresh); // 保存状态
        
        const baseScrollAmount = 0.5; // 降低基础滚动量，因为帧率提高了
        const scrollAmount = baseScrollAmount * speed; // 根据速度调整滚动量
        let isPaused = false;
        let lastScrollHeight = 0;
        let scrollPosition = window.scrollY;
        let isScrollingToTop = false;
        const FRAME_INTERVAL = 16; // 60fps = 16ms per frame
        let lastFrameTime = Date.now();

        // 设置自动刷新检查
        if (isAutoRefreshEnabled) {
            refreshInterval = setInterval(async () => {
                const currentTime = Date.now();
                const timeSinceLastRefresh = (currentTime - lastRefreshTime) / 1000 / 60; // 转换为分钟
                
                // 每3分钟执行一次刷新序列
                if (timeSinceLastRefresh >= 3) {
                    // 停止滚动
                    if (scrollInterval) {
                        clearInterval(scrollInterval);
                        scrollInterval = null;
                    }
                    
                    // 休息2秒
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    // 回到顶部
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    
                    // 休息2秒
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    // 保存当前状态
                    const currentState = {
                        speed: currentSpeed,
                        autoRefresh: isAutoRefreshEnabled,
                        timestamp: Date.now()
                    };
                    sessionStorage.setItem('scrollState', JSON.stringify(currentState));
                    
                    // 刷新页面
                    window.location.reload();
                }
            }, 10000); // 每10秒检查一次
        }

        // 使用 setInterval 保持稳定的帧率
        scrollInterval = setInterval(() => {
            if (isPaused || isScrollingToTop) return;

            const currentTime = Date.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            const scrollHeight = document.documentElement.scrollHeight;
            const windowHeight = window.innerHeight;
            const currentScroll = window.scrollY;
            const distanceToBottom = scrollHeight - (currentScroll + windowHeight);

            // 当接近底部时
            if (distanceToBottom < 100) {
                if (!isPaused) {
                    isPaused = true;
                    lastScrollHeight = scrollHeight;

                    // 检查是否有新内容加载
                    setTimeout(() => {
                        const newScrollHeight = document.documentElement.scrollHeight;
                        if (newScrollHeight === lastScrollHeight) {
                            // 如果确实到达底部，平滑滚动到顶部
                            isScrollingToTop = true;
                            const startPosition = window.scrollY;
                            const startTime = Date.now();
                            const duration = 800; // 稍微加快回到顶部的速度
                            let lastTopFrameTime = startTime;

                            function scrollToTop() {
                                if (!isScrollingToTop) return;

                                const currentTime = Date.now();
                                const elapsed = currentTime - startTime;
                                const progress = Math.min(elapsed / duration, 1);

                                // 使用 easeInOutQuad 缓动函数使滚动更自然
                                const easeProgress = progress < 0.5 
                                    ? 2 * progress * progress 
                                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                                window.scrollTo(0, startPosition * (1 - easeProgress));

                                if (progress < 1) {
                                    requestAnimationFrame(scrollToTop);
                                } else {
                                    isScrollingToTop = false;
                                    isPaused = false;
                                    scrollPosition = 0;
                                    lastFrameTime = Date.now(); // 重置帧时间
                                }
                            }

                            requestAnimationFrame(scrollToTop);
                        } else {
                            // 如果有新内容，继续滚动
                            isPaused = false;
                            lastFrameTime = Date.now(); // 重置帧时间
                        }
                    }, 1000);
                }
            } else {
                // 正常滚动，使用 deltaTime 来保持稳定的滚动速度
                scrollPosition += scrollAmount * (deltaTime / FRAME_INTERVAL);
                window.scrollTo(0, scrollPosition);
            }
        }, FRAME_INTERVAL);

        // 清理函数
        return () => {
            if (scrollInterval) {
                clearInterval(scrollInterval);
            }
            isScrollingToTop = false;
            isPaused = false;
        };
    }
  
    function stopScroll() {
        if (scrollInterval) {
            clearInterval(scrollInterval);
            scrollInterval = null;
        }
        if (refreshInterval) {
            clearInterval(refreshInterval);
            refreshInterval = null;
        }
        currentSpeed = 1;
        isAutoRefreshEnabled = false;
        shouldAutoScroll = false; // 清除自动滚动标记
        clearScrollState(); // 清除保存的状态
    }
  
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
        if (message.action === 'startScroll') {
            smoothAutoScroll(message.speed || 1, message.autoRefresh || false);
        } else if (message.action === 'stopScroll') {
            stopScroll();
        }
    });

    // 页面加载完成后检查是否需要恢复滚动
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', checkAndRestoreScrollState);
    } else {
        checkAndRestoreScrollState();
    }
})();

完整的路径: D:\JS\chrome_extension\aiTools\turndown.js
内容:
var TurndownService = (function () {
  'use strict';

  function extend (destination) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (source.hasOwnProperty(key)) destination[key] = source[key];
      }
    }
    return destination
  }

  function repeat (character, count) {
    return Array(count + 1).join(character)
  }

  function trimLeadingNewlines (string) {
    return string.replace(/^\n*/, '')
  }

  function trimTrailingNewlines (string) {
    // avoid match-at-end regexp bottleneck, see #370
    var indexEnd = string.length;
    while (indexEnd > 0 && string[indexEnd - 1] === '\n') indexEnd--;
    return string.substring(0, indexEnd)
  }

  var blockElements = [
    'ADDRESS', 'ARTICLE', 'ASIDE', 'AUDIO', 'BLOCKQUOTE', 'BODY', 'CANVAS',
    'CENTER', 'DD', 'DIR', 'DIV', 'DL', 'DT', 'FIELDSET', 'FIGCAPTION', 'FIGURE',
    'FOOTER', 'FORM', 'FRAMESET', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HEADER',
    'HGROUP', 'HR', 'HTML', 'ISINDEX', 'LI', 'MAIN', 'MENU', 'NAV', 'NOFRAMES',
    'NOSCRIPT', 'OL', 'OUTPUT', 'P', 'PRE', 'SECTION', 'TABLE', 'TBODY', 'TD',
    'TFOOT', 'TH', 'THEAD', 'TR', 'UL'
  ];

  function isBlock (node) {
    return is(node, blockElements)
  }

  var voidElements = [
    'AREA', 'BASE', 'BR', 'COL', 'COMMAND', 'EMBED', 'HR', 'IMG', 'INPUT',
    'KEYGEN', 'LINK', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR'
  ];

  function isVoid (node) {
    return is(node, voidElements)
  }

  function hasVoid (node) {
    return has(node, voidElements)
  }

  var meaningfulWhenBlankElements = [
    'A', 'TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TH', 'TD', 'IFRAME', 'SCRIPT',
    'AUDIO', 'VIDEO'
  ];

  function isMeaningfulWhenBlank (node) {
    return is(node, meaningfulWhenBlankElements)
  }

  function hasMeaningfulWhenBlank (node) {
    return has(node, meaningfulWhenBlankElements)
  }

  function is (node, tagNames) {
    return tagNames.indexOf(node.nodeName) >= 0
  }

  function has (node, tagNames) {
    return (
      node.getElementsByTagName &&
      tagNames.some(function (tagName) {
        return node.getElementsByTagName(tagName).length
      })
    )
  }

  var rules = {};

  rules.paragraph = {
    filter: 'p',

    replacement: function (content) {
      return '\n\n' + content + '\n\n'
    }
  };

  rules.lineBreak = {
    filter: 'br',

    replacement: function (content, node, options) {
      return options.br + '\n'
    }
  };

  rules.heading = {
    filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],

    replacement: function (content, node, options) {
      var hLevel = Number(node.nodeName.charAt(1));

      if (options.headingStyle === 'setext' && hLevel < 3) {
        var underline = repeat((hLevel === 1 ? '=' : '-'), content.length);
        return (
          '\n\n' + content + '\n' + underline + '\n\n'
        )
      } else {
        return '\n\n' + repeat('#', hLevel) + ' ' + content + '\n\n'
      }
    }
  };

  rules.blockquote = {
    filter: 'blockquote',

    replacement: function (content) {
      content = content.replace(/^\n+|\n+$/g, '');
      content = content.replace(/^/gm, '> ');
      return '\n\n' + content + '\n\n'
    }
  };

  rules.list = {
    filter: ['ul', 'ol'],

    replacement: function (content, node) {
      var parent = node.parentNode;
      if (parent.nodeName === 'LI' && parent.lastElementChild === node) {
        return '\n' + content
      } else {
        return '\n\n' + content + '\n\n'
      }
    }
  };

  rules.listItem = {
    filter: 'li',

    replacement: function (content, node, options) {
      content = content
        .replace(/^\n+/, '') // remove leading newlines
        .replace(/\n+$/, '\n') // replace trailing newlines with just a single one
        .replace(/\n/gm, '\n    '); // indent
      var prefix = options.bulletListMarker + '   ';
      var parent = node.parentNode;
      if (parent.nodeName === 'OL') {
        var start = parent.getAttribute('start');
        var index = Array.prototype.indexOf.call(parent.children, node);
        prefix = (start ? Number(start) + index : index + 1) + '.  ';
      }
      return (
        prefix + content + (node.nextSibling && !/\n$/.test(content) ? '\n' : '')
      )
    }
  };

  rules.indentedCodeBlock = {
    filter: function (node, options) {
      return (
        options.codeBlockStyle === 'indented' &&
        node.nodeName === 'PRE' &&
        node.firstChild &&
        node.firstChild.nodeName === 'CODE'
      )
    },

    replacement: function (content, node, options) {
      return (
        '\n\n    ' +
        node.firstChild.textContent.replace(/\n/g, '\n    ') +
        '\n\n'
      )
    }
  };

  rules.fencedCodeBlock = {
    filter: function (node, options) {
      return (
        options.codeBlockStyle === 'fenced' &&
        node.nodeName === 'PRE' &&
        node.firstChild &&
        node.firstChild.nodeName === 'CODE'
      )
    },

    replacement: function (content, node, options) {
      var className = node.firstChild.getAttribute('class') || '';
      var language = (className.match(/language-(\S+)/) || [null, ''])[1];
      var code = node.firstChild.textContent;

      var fenceChar = options.fence.charAt(0);
      var fenceSize = 3;
      var fenceInCodeRegex = new RegExp('^' + fenceChar + '{3,}', 'gm');

      var match;
      while ((match = fenceInCodeRegex.exec(code))) {
        if (match[0].length >= fenceSize) {
          fenceSize = match[0].length + 1;
        }
      }

      var fence = repeat(fenceChar, fenceSize);

      return (
        '\n\n' + fence + language + '\n' +
        code.replace(/\n$/, '') +
        '\n' + fence + '\n\n'
      )
    }
  };

  rules.horizontalRule = {
    filter: 'hr',

    replacement: function (content, node, options) {
      return '\n\n' + options.hr + '\n\n'
    }
  };

  rules.inlineLink = {
    filter: function (node, options) {
      return (
        options.linkStyle === 'inlined' &&
        node.nodeName === 'A' &&
        node.getAttribute('href')
      )
    },

    replacement: function (content, node) {
      var href = node.getAttribute('href');
      var title = cleanAttribute(node.getAttribute('title'));
      if (title) title = ' "' + title + '"';
      return '[' + content + '](' + href + title + ')'
    }
  };

  rules.referenceLink = {
    filter: function (node, options) {
      return (
        options.linkStyle === 'referenced' &&
        node.nodeName === 'A' &&
        node.getAttribute('href')
      )
    },

    replacement: function (content, node, options) {
      var href = node.getAttribute('href');
      var title = cleanAttribute(node.getAttribute('title'));
      if (title) title = ' "' + title + '"';
      var replacement;
      var reference;

      switch (options.linkReferenceStyle) {
        case 'collapsed':
          replacement = '[' + content + '][]';
          reference = '[' + content + ']: ' + href + title;
          break
        case 'shortcut':
          replacement = '[' + content + ']';
          reference = '[' + content + ']: ' + href + title;
          break
        default:
          var id = this.references.length + 1;
          replacement = '[' + content + '][' + id + ']';
          reference = '[' + id + ']: ' + href + title;
      }

      this.references.push(reference);
      return replacement
    },

    references: [],

    append: function (options) {
      var references = '';
      if (this.references.length) {
        references = '\n\n' + this.references.join('\n') + '\n\n';
        this.references = []; // Reset references
      }
      return references
    }
  };

  rules.emphasis = {
    filter: ['em', 'i'],

    replacement: function (content, node, options) {
      if (!content.trim()) return ''
      return options.emDelimiter + content + options.emDelimiter
    }
  };

  rules.strong = {
    filter: ['strong', 'b'],

    replacement: function (content, node, options) {
      if (!content.trim()) return ''
      return options.strongDelimiter + content + options.strongDelimiter
    }
  };

  rules.code = {
    filter: function (node) {
      var hasSiblings = node.previousSibling || node.nextSibling;
      var isCodeBlock = node.parentNode.nodeName === 'PRE' && !hasSiblings;

      return node.nodeName === 'CODE' && !isCodeBlock
    },

    replacement: function (content) {
      if (!content) return ''
      content = content.replace(/\r?\n|\r/g, ' ');

      var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? ' ' : '';
      var delimiter = '`';
      var matches = content.match(/`+/gm) || [];
      while (matches.indexOf(delimiter) !== -1) delimiter = delimiter + '`';

      return delimiter + extraSpace + content + extraSpace + delimiter
    }
  };

  rules.image = {
    filter: 'img',

    replacement: function (content, node) {
      var alt = cleanAttribute(node.getAttribute('alt'));
      var src = node.getAttribute('src') || '';
      var title = cleanAttribute(node.getAttribute('title'));
      var titlePart = title ? ' "' + title + '"' : '';
      return src ? '![' + alt + ']' + '(' + src + titlePart + ')' : ''
    }
  };

  function cleanAttribute (attribute) {
    return attribute ? attribute.replace(/(\n+\s*)+/g, '\n') : ''
  }

  /**
   * Manages a collection of rules used to convert HTML to Markdown
   */

  function Rules (options) {
    this.options = options;
    this._keep = [];
    this._remove = [];

    this.blankRule = {
      replacement: options.blankReplacement
    };

    this.keepReplacement = options.keepReplacement;

    this.defaultRule = {
      replacement: options.defaultReplacement
    };

    this.array = [];
    for (var key in options.rules) this.array.push(options.rules[key]);
  }

  Rules.prototype = {
    add: function (key, rule) {
      this.array.unshift(rule);
    },

    keep: function (filter) {
      this._keep.unshift({
        filter: filter,
        replacement: this.keepReplacement
      });
    },

    remove: function (filter) {
      this._remove.unshift({
        filter: filter,
        replacement: function () {
          return ''
        }
      });
    },

    forNode: function (node) {
      if (node.isBlank) return this.blankRule
      var rule;

      if ((rule = findRule(this.array, node, this.options))) return rule
      if ((rule = findRule(this._keep, node, this.options))) return rule
      if ((rule = findRule(this._remove, node, this.options))) return rule

      return this.defaultRule
    },

    forEach: function (fn) {
      for (var i = 0; i < this.array.length; i++) fn(this.array[i], i);
    }
  };

  function findRule (rules, node, options) {
    for (var i = 0; i < rules.length; i++) {
      var rule = rules[i];
      if (filterValue(rule, node, options)) return rule
    }
    return void 0
  }

  function filterValue (rule, node, options) {
    var filter = rule.filter;
    if (typeof filter === 'string') {
      if (filter === node.nodeName.toLowerCase()) return true
    } else if (Array.isArray(filter)) {
      if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true
    } else if (typeof filter === 'function') {
      if (filter.call(rule, node, options)) return true
    } else {
      throw new TypeError('`filter` needs to be a string, array, or function')
    }
  }

  /**
   * The collapseWhitespace function is adapted from collapse-whitespace
   * by Luc Thevenard.
   *
   * The MIT License (MIT)
   *
   * Copyright (c) 2014 Luc Thevenard <lucthevenard@gmail.com>
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /**
   * collapseWhitespace(options) removes extraneous whitespace from an the given element.
   *
   * @param {Object} options
   */
  function collapseWhitespace (options) {
    var element = options.element;
    var isBlock = options.isBlock;
    var isVoid = options.isVoid;
    var isPre = options.isPre || function (node) {
      return node.nodeName === 'PRE'
    };

    if (!element.firstChild || isPre(element)) return

    var prevText = null;
    var keepLeadingWs = false;

    var prev = null;
    var node = next(prev, element, isPre);

    while (node !== element) {
      if (node.nodeType === 3 || node.nodeType === 4) { // Node.TEXT_NODE or Node.CDATA_SECTION_NODE
        var text = node.data.replace(/[ \r\n\t]+/g, ' ');

        if ((!prevText || / $/.test(prevText.data)) &&
            !keepLeadingWs && text[0] === ' ') {
          text = text.substr(1);
        }

        // `text` might be empty at this point.
        if (!text) {
          node = remove(node);
          continue
        }

        node.data = text;

        prevText = node;
      } else if (node.nodeType === 1) { // Node.ELEMENT_NODE
        if (isBlock(node) || node.nodeName === 'BR') {
          if (prevText) {
            prevText.data = prevText.data.replace(/ $/, '');
          }

          prevText = null;
          keepLeadingWs = false;
        } else if (isVoid(node) || isPre(node)) {
          // Avoid trimming space around non-block, non-BR void elements and inline PRE.
          prevText = null;
          keepLeadingWs = true;
        } else if (prevText) {
          // Drop protection if set previously.
          keepLeadingWs = false;
        }
      } else {
        node = remove(node);
        continue
      }

      var nextNode = next(prev, node, isPre);
      prev = node;
      node = nextNode;
    }

    if (prevText) {
      prevText.data = prevText.data.replace(/ $/, '');
      if (!prevText.data) {
        remove(prevText);
      }
    }
  }

  /**
   * remove(node) removes the given node from the DOM and returns the
   * next node in the sequence.
   *
   * @param {Node} node
   * @return {Node} node
   */
  function remove (node) {
    var next = node.nextSibling || node.parentNode;

    node.parentNode.removeChild(node);

    return next
  }

  /**
   * next(prev, current, isPre) returns the next node in the sequence, given the
   * current and previous nodes.
   *
   * @param {Node} prev
   * @param {Node} current
   * @param {Function} isPre
   * @return {Node}
   */
  function next (prev, current, isPre) {
    if ((prev && prev.parentNode === current) || isPre(current)) {
      return current.nextSibling || current.parentNode
    }

    return current.firstChild || current.nextSibling || current.parentNode
  }

  /*
   * Set up window for Node.js
   */

  var root = (typeof window !== 'undefined' ? window : {});

  /*
   * Parsing HTML strings
   */

  function canParseHTMLNatively () {
    var Parser = root.DOMParser;
    var canParse = false;

    // Adapted from https://gist.github.com/1129031
    // Firefox/Opera/IE throw errors on unsupported types
    try {
      // WebKit returns null on unsupported types
      if (new Parser().parseFromString('', 'text/html')) {
        canParse = true;
      }
    } catch (e) {}

    return canParse
  }

  function createHTMLParser () {
    var Parser = function () {};

    {
      if (shouldUseActiveX()) {
        Parser.prototype.parseFromString = function (string) {
          var doc = new window.ActiveXObject('htmlfile');
          doc.designMode = 'on'; // disable on-page scripts
          doc.open();
          doc.write(string);
          doc.close();
          return doc
        };
      } else {
        Parser.prototype.parseFromString = function (string) {
          var doc = document.implementation.createHTMLDocument('');
          doc.open();
          doc.write(string);
          doc.close();
          return doc
        };
      }
    }
    return Parser
  }

  function shouldUseActiveX () {
    var useActiveX = false;
    try {
      document.implementation.createHTMLDocument('').open();
    } catch (e) {
      if (window.ActiveXObject) useActiveX = true;
    }
    return useActiveX
  }

  var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();

  function RootNode (input, options) {
    var root;
    if (typeof input === 'string') {
      var doc = htmlParser().parseFromString(
        // DOM parsers arrange elements in the <head> and <body>.
        // Wrapping in a custom element ensures elements are reliably arranged in
        // a single element.
        '<x-turndown id="turndown-root">' + input + '</x-turndown>',
        'text/html'
      );
      root = doc.getElementById('turndown-root');
    } else {
      root = input.cloneNode(true);
    }
    collapseWhitespace({
      element: root,
      isBlock: isBlock,
      isVoid: isVoid,
      isPre: options.preformattedCode ? isPreOrCode : null
    });

    return root
  }

  var _htmlParser;
  function htmlParser () {
    _htmlParser = _htmlParser || new HTMLParser();
    return _htmlParser
  }

  function isPreOrCode (node) {
    return node.nodeName === 'PRE' || node.nodeName === 'CODE'
  }

  function Node (node, options) {
    node.isBlock = isBlock(node);
    node.isCode = node.nodeName === 'CODE' || node.parentNode.isCode;
    node.isBlank = isBlank(node);
    node.flankingWhitespace = flankingWhitespace(node, options);
    return node
  }

  function isBlank (node) {
    return (
      !isVoid(node) &&
      !isMeaningfulWhenBlank(node) &&
      /^\s*$/i.test(node.textContent) &&
      !hasVoid(node) &&
      !hasMeaningfulWhenBlank(node)
    )
  }

  function flankingWhitespace (node, options) {
    if (node.isBlock || (options.preformattedCode && node.isCode)) {
      return { leading: '', trailing: '' }
    }

    var edges = edgeWhitespace(node.textContent);

    // abandon leading ASCII WS if left-flanked by ASCII WS
    if (edges.leadingAscii && isFlankedByWhitespace('left', node, options)) {
      edges.leading = edges.leadingNonAscii;
    }

    // abandon trailing ASCII WS if right-flanked by ASCII WS
    if (edges.trailingAscii && isFlankedByWhitespace('right', node, options)) {
      edges.trailing = edges.trailingNonAscii;
    }

    return { leading: edges.leading, trailing: edges.trailing }
  }

  function edgeWhitespace (string) {
    var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
    return {
      leading: m[1], // whole string for whitespace-only strings
      leadingAscii: m[2],
      leadingNonAscii: m[3],
      trailing: m[4], // empty for whitespace-only strings
      trailingNonAscii: m[5],
      trailingAscii: m[6]
    }
  }

  function isFlankedByWhitespace (side, node, options) {
    var sibling;
    var regExp;
    var isFlanked;

    if (side === 'left') {
      sibling = node.previousSibling;
      regExp = / $/;
    } else {
      sibling = node.nextSibling;
      regExp = /^ /;
    }

    if (sibling) {
      if (sibling.nodeType === 3) {
        isFlanked = regExp.test(sibling.nodeValue);
      } else if (options.preformattedCode && sibling.nodeName === 'CODE') {
        isFlanked = false;
      } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
        isFlanked = regExp.test(sibling.textContent);
      }
    }
    return isFlanked
  }

  var reduce = Array.prototype.reduce;
  var escapes = [
    [/\\/g, '\\\\'],
    [/\*/g, '\\*'],
    [/^-/g, '\\-'],
    [/^\+ /g, '\\+ '],
    [/^(=+)/g, '\\$1'],
    [/^(#{1,6}) /g, '\\$1 '],
    [/`/g, '\\`'],
    [/^~~~/g, '\\~~~'],
    [/\[/g, '\\['],
    [/\]/g, '\\]'],
    [/^>/g, '\\>'],
    [/_/g, '\\_'],
    [/^(\d+)\. /g, '$1\\. ']
  ];

  function TurndownService (options) {
    if (!(this instanceof TurndownService)) return new TurndownService(options)

    var defaults = {
      rules: rules,
      headingStyle: 'setext',
      hr: '* * *',
      bulletListMarker: '*',
      codeBlockStyle: 'indented',
      fence: '```',
      emDelimiter: '_',
      strongDelimiter: '**',
      linkStyle: 'inlined',
      linkReferenceStyle: 'full',
      br: '  ',
      preformattedCode: false,
      blankReplacement: function (content, node) {
        return node.isBlock ? '\n\n' : ''
      },
      keepReplacement: function (content, node) {
        return node.isBlock ? '\n\n' + node.outerHTML + '\n\n' : node.outerHTML
      },
      defaultReplacement: function (content, node) {
        return node.isBlock ? '\n\n' + content + '\n\n' : content
      }
    };
    this.options = extend({}, defaults, options);
    this.rules = new Rules(this.options);
  }

  TurndownService.prototype = {
    /**
     * The entry point for converting a string or DOM node to Markdown
     * @public
     * @param {String|HTMLElement} input The string or DOM node to convert
     * @returns A Markdown representation of the input
     * @type String
     */

    turndown: function (input) {
      if (!canConvert(input)) {
        throw new TypeError(
          input + ' is not a string, or an element/document/fragment node.'
        )
      }

      if (input === '') return ''

      var output = process.call(this, new RootNode(input, this.options));
      return postProcess.call(this, output)
    },

    /**
     * Add one or more plugins
     * @public
     * @param {Function|Array} plugin The plugin or array of plugins to add
     * @returns The Turndown instance for chaining
     * @type Object
     */

    use: function (plugin) {
      if (Array.isArray(plugin)) {
        for (var i = 0; i < plugin.length; i++) this.use(plugin[i]);
      } else if (typeof plugin === 'function') {
        plugin(this);
      } else {
        throw new TypeError('plugin must be a Function or an Array of Functions')
      }
      return this
    },

    /**
     * Adds a rule
     * @public
     * @param {String} key The unique key of the rule
     * @param {Object} rule The rule
     * @returns The Turndown instance for chaining
     * @type Object
     */

    addRule: function (key, rule) {
      this.rules.add(key, rule);
      return this
    },

    /**
     * Keep a node (as HTML) that matches the filter
     * @public
     * @param {String|Array|Function} filter The unique key of the rule
     * @returns The Turndown instance for chaining
     * @type Object
     */

    keep: function (filter) {
      this.rules.keep(filter);
      return this
    },

    /**
     * Remove a node that matches the filter
     * @public
     * @param {String|Array|Function} filter The unique key of the rule
     * @returns The Turndown instance for chaining
     * @type Object
     */

    remove: function (filter) {
      this.rules.remove(filter);
      return this
    },

    /**
     * Escapes Markdown syntax
     * @public
     * @param {String} string The string to escape
     * @returns A string with Markdown syntax escaped
     * @type String
     */

    escape: function (string) {
      return escapes.reduce(function (accumulator, escape) {
        return accumulator.replace(escape[0], escape[1])
      }, string)
    }
  };

  /**
   * Reduces a DOM node down to its Markdown string equivalent
   * @private
   * @param {HTMLElement} parentNode The node to convert
   * @returns A Markdown representation of the node
   * @type String
   */

  function process (parentNode) {
    var self = this;
    return reduce.call(parentNode.childNodes, function (output, node) {
      node = new Node(node, self.options);

      var replacement = '';
      if (node.nodeType === 3) {
        replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
      } else if (node.nodeType === 1) {
        replacement = replacementForNode.call(self, node);
      }

      return join(output, replacement)
    }, '')
  }

  /**
   * Appends strings as each rule requires and trims the output
   * @private
   * @param {String} output The conversion output
   * @returns A trimmed version of the ouput
   * @type String
   */

  function postProcess (output) {
    var self = this;
    this.rules.forEach(function (rule) {
      if (typeof rule.append === 'function') {
        output = join(output, rule.append(self.options));
      }
    });

    return output.replace(/^[\t\r\n]+/, '').replace(/[\t\r\n\s]+$/, '')
  }

  /**
   * Converts an element node to its Markdown equivalent
   * @private
   * @param {HTMLElement} node The node to convert
   * @returns A Markdown representation of the node
   * @type String
   */

  function replacementForNode (node) {
    var rule = this.rules.forNode(node);
    var content = process.call(this, node);
    var whitespace = node.flankingWhitespace;
    if (whitespace.leading || whitespace.trailing) content = content.trim();
    return (
      whitespace.leading +
      rule.replacement(content, node, this.options) +
      whitespace.trailing
    )
  }

  /**
   * Joins replacement to the current output with appropriate number of new lines
   * @private
   * @param {String} output The current conversion output
   * @param {String} replacement The string to append to the output
   * @returns Joined output
   * @type String
   */

  function join (output, replacement) {
    var s1 = trimTrailingNewlines(output);
    var s2 = trimLeadingNewlines(replacement);
    var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
    var separator = '\n\n'.substring(0, nls);

    return s1 + separator + s2
  }

  /**
   * Determines whether an input can be converted
   * @private
   * @param {String|HTMLElement} input Describe this parameter
   * @returns Describe what it returns
   * @type String|Object|Array|Boolean|Number
   */

  function canConvert (input) {
    return (
      input != null && (
        typeof input === 'string' ||
        (input.nodeType && (
          input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11
        ))
      )
    )
  }

  return TurndownService;

}());


完整的路径: D:\JS\chrome_extension\aiTools\做的过程.md
内容:
# todo
1. 我想把 滚动功能，单独拿出来， 作为一个插件。
   因为是对所有网站都起作用，所以，容易出错！
2. 把此项目重命名，因为 myChromeTools 太宽泛了。
   - 而此项目，是针对几个 AI 网站，进行特殊处理。
   - myChatTools   




# 我想把 grok 输出的内容， 转为md， 失败！


# 修改内容
- 把原来的 content.js 拆分为4个文件，方便单独管理， 以及后面的拓展。
- 以后再新增功能， 先在 manifest.json  matches 中增加配置， 然后新建一个js


# 文件的作用
- manifest.json 是入口，所有其他文件的运行都依赖于它的配置。
- background.js  


# 目的
此项目，某些特定网站上，进行特别的操作。 个性化操作。

聊天记录:

https://x.com/i/grok?conversation=1922691362044117397


# 新增：
- 自动下载原始尺寸的图片 https://ca.pinterest.com/
- 那么就把  736x 或 1200x， 自动替换为 originals


1. 增加输入框的高度，可以增加 25px
2. 光标自动聚集在输入框内


### 生成图片， icon 
https://chatgpt.com/c/6824c447-bcb4-8002-a576-4e72aa876c2d

要求如下：
1. **图标风格偏好**： 积极向上。 
2. **是否希望包含字母**： 写上工具2个字。
3. **配色喜好**： 彩色，我喜欢彩虹色，即多种颜色。
4. **是否希望图中有工具元素**：如螺丝刀、扳手、工具箱图案， 很合适
5. **是否有图标尺寸需求**： 512×512 


# 创建项目的步骤
1. 新建一个 manifest.json 文件, 填入一些信息。
"manifest_version": 3,  # 2 已经被废弃了。
2. 新建图片文件夹，准备图片
3. 打开：chrome://extensions/， 上传 插件文件夹


### manifest.json 内容

#### 1. matches 的用法
- "matches": ["https://www.google.com/*"], 只限定某个域名
- "matches": ["*://*/*"], 全部的网站。
- "matches": ["<all_urls>"], 全部的网站。


### 2. "run_at": 有以下几种值
- "document_start"
- "document_end"
- "document_idle"

sublime 的默认背景颜色是 
bg:
#303841
rgba(48,56,65,255)

text:
#d8dfea
rgba(216,223,234,255)



完整的路径: D:\JS\chrome_extension\aiTools\建议.md
内容:
# aiTools 项目优化建议

基于对整个项目的分析，以下是详细的优化和改进建议：

## 代码结构优化建议

### 1. 配置管理优化

- **建议创建统一配置文件**：将各个脚本的配置参数（如时间间隔、选择器等）集中到一个配置文件中，便于维护和调整
- **环境区分**：考虑添加开发/生产环境的配置区分，方便调试和发布

### 2. 错误处理和日志系统

- **统一错误处理**：各个内容脚本的错误处理方式不一致，建议创建统一的错误处理机制
- **日志级别管理**：当前 console.log 较多，建议添加日志级别控制（debug/info/warn/error）
- **用户友好的错误提示**：考虑在扩展 popup 中显示功能状态和错误信息

### 3. 性能优化

- **MutationObserver 优化**：多个脚本都使用了 MutationObserver，可以考虑优化观察范围和频率
- **内存泄漏防护**：确保所有定时器和事件监听器都有清理机制
- **懒加载**：对于不常用的功能，考虑按需加载

## 功能增强建议

### 4. 用户体验改进

- **功能开关**：在 popup 中添加各个网站功能的开关，让用户可以选择性启用/禁用
- **设置页面**：创建一个设置页面，允许用户自定义各种参数（如滚动速度、保存间隔等）
- **状态指示**：在扩展图标上显示当前活跃功能的状态

### 5. 功能扩展

- **快捷键管理**：当前只有 Grok 有快捷键，考虑为其他功能也添加快捷键支持
- **数据同步**：考虑使用 chrome.storage.sync 来同步用户设置到不同设备
- **使用统计**：添加功能使用统计，帮助了解哪些功能最受欢迎

## 代码质量提升

### 6. 代码规范

- **ESLint 配置**：添加 ESLint 配置文件，统一代码风格
- **TypeScript 迁移**：考虑逐步迁移到 TypeScript，提高代码可维护性
- **模块化**：将公共功能抽取为独立模块，减少代码重复

### 7. 测试和文档

- **单元测试**：为核心功能添加单元测试
- **用户手册**：创建更详细的用户使用手册，包含截图和步骤说明
- **开发文档**：添加开发者文档，说明如何添加新的网站支持

## 安全和兼容性

### 8. 安全性增强

- **权限最小化**：检查 manifest.json 中的权限，确保只申请必要的权限
- **内容安全策略**：添加 CSP 规则，防止 XSS 攻击
- **输入验证**：对用户输入和网页内容进行适当的验证和清理

### 9. 兼容性改进

- **浏览器兼容**：考虑支持其他基于 Chromium 的浏览器（Edge、Opera 等）
- **网站变更适应**：建立机制来应对目标网站的 DOM 结构变更
- **版本管理**：建立更好的版本管理和更新机制

## 项目管理建议

### 10. 开发流程

- **Git 工作流**：优化 Git 工作流，添加分支策略和代码审查流程
- **自动化构建**：添加构建脚本，自动化打包和发布流程
- **版本发布**：建立规范的版本发布流程，包含 changelog 和升级指南

### 11. 监控和反馈

- **错误收集**：考虑添加错误收集机制，了解用户遇到的问题
- **用户反馈**：建立用户反馈渠道，收集功能需求和 bug 报告
- **性能监控**：添加性能监控，了解扩展对浏览器性能的影响

## 特定功能优化建议

### 12. Medium 功能

- **选择器稳定性**：Medium 的 DOM 结构可能会变化，建议使用更稳定的选择器或多重备选方案
- **用户选择**：考虑让用户选择是否完全隐藏菜单，或者只隐藏特定按钮

### 13. 滚动功能

- **智能暂停**：检测用户手动滚动时自动暂停自动滚动
- **页面类型识别**：对不同类型的页面（如无限滚动、分页等）采用不同的滚动策略

### 14. Grok 功能

- **多语言支持**：预设文本支持多语言配置
- **模板管理**：允许用户自定义和管理多个文本模板

### 15. Pinterest 功能

- **下载路径管理**：允许用户自定义图片下载路径
- **批量下载**：支持批量下载多张图片
- **图片格式转换**：考虑添加图片格式转换功能

### 16. Google AI Studio 功能

- **保存确认**：添加保存成功/失败的视觉反馈
- **备份机制**：考虑添加本地备份功能，防止数据丢失

## 实施优先级建议

### 高优先级（立即实施）

1. 统一错误处理和日志系统
2. 功能开关和用户设置
3. 代码规范和 ESLint 配置
4. 安全性检查和权限优化

### 中优先级（短期实施）

1. 性能优化和内存管理
2. 用户体验改进
3. 测试框架搭建
4. 文档完善

### 低优先级（长期规划）

1. TypeScript 迁移
2. 多浏览器支持
3. 高级功能扩展
4. 监控和分析系统

## 技术债务清理

### 代码重构

- **重复代码消除**：多个脚本中存在相似的 DOM 操作和事件处理逻辑
- **函数拆分**：部分函数过长，建议拆分为更小的功能单元
- **命名规范**：统一变量和函数的命名规范

### 架构改进

- **插件化架构**：考虑将各网站功能设计为插件，便于扩展和维护
- **事件驱动**：使用事件驱动模式来解耦各个功能模块
- **状态管理**：建立统一的状态管理机制

这些建议可以分阶段实施，建议优先考虑用户体验和代码质量相关的改进，然后逐步实施其他优化措施。


完整的路径: D:\JS\chrome_extension\aiTools\说明.md
内容:
# aiTools - Chrome 扩展程序项目说明

## 项目背景

这是一个名为 **aiTools** 的 Chrome 浏览器扩展项目，专门为几个 AI 相关网站提供个性化增强功能。项目使用 Manifest V3 规范，旨在为特定的 AI 网站提供自动化操作和用户体验优化，支持多个 AI 平台的特殊处理。

## 针对不同网站的特别处理

### 1. **Grok 网站** (`x.com/i/grok` 和 `grok.com`)

#### 界面自动优化 (`grok_content.js`)

- **专注模式自动激活**：自动点击"专注模式"按钮，获得更清洁的对话视图
- **输入框优化**：自动调整输入框高度至 86px，提供更舒适的输入体验
- **自动聚焦**：页面加载后自动将光标聚焦到输入框，可立即开始输入

#### 快捷键文本插入 (`grok_insert_text.js`)

- **快捷键支持**：`Ctrl+Q` (Windows/Linux) 或 `Command+Shift+G` (Mac)
- **预设文本**：自动插入中文提示文本："你是一名计算机专家，编程高手。我是一名普通程序员。请用中文来解释。"
- **智能检测**：自动检测页面中的输入框（textarea 或 text input）

### 2. **Pinterest 图片** (`i.pinimg.com`)

#### 自动获取原图 (`pinterest_content.js`)

- **URL 自动转换**：将图片 URL 中的尺寸标识（`736x`、`1200x`）自动替换为`originals`
- **无缝跳转**：自动跳转到原始尺寸图片页面
- **智能下载**：检测到原始图片后自动触发浏览器下载
- **多重检测**：结合页面加载事件和 DOM 监控，确保下载成功触发

### 3. **Google AI Studio** (`aistudio.google.com/prompts/`)

#### 自动保存功能 (`gemini_auto_save.js`)

- **定时保存**：每 30 秒自动尝试点击"保存 Prompt"按钮
- **智能检测**：检查按钮状态（是否存在、是否可用、是否可见）
- **防丢失保护**：防止长时间编辑时意外丢失未保存的内容
- **状态日志**：详细的操作日志，便于调试和监控

### 4. **Medium** (`medium.com`)

#### 隐藏文本选择菜单 (`medium_content.js`)

- **菜单隐藏**：自动隐藏选中文本时弹出的操作菜单（强调、回应、分享、私人笔记等按钮）
- **清洁阅读**：提供更清洁的阅读体验，避免选择文本时的界面干扰
- **多重保障**：使用 CSS 样式和动态监控相结合，确保菜单始终保持隐藏状态
- **兼容性强**：支持多种选择器，适应网站结构变化

### 5. **通用滚动控制** (所有网站)

#### 智能滚动系统 (`scroll_control.js` + `popup.js`)

- **多速度选择**：提供正常、5 倍速、10 倍速三种自动滚动选项
- **自动刷新机制**：滚动 3 分钟后自动执行：停止滚动 → 回到顶部 → 刷新页面
- **状态持久化**：滚动状态保存在会话中，刷新后 5 分钟内自动恢复
- **智能底部检测**：到达页面底部后自动平滑滚动回顶部继续
- **兼容性检查**：自动检测页面类型，对特殊页面（chrome://、扩展页面等）禁用功能
- **用户友好界面**：显示当前域名，提供直观的控制按钮

## 技术架构

### 核心文件结构

```
aiTools/
├── manifest.json          # 扩展配置入口，定义权限和内容脚本
├── background.js          # 后台服务，处理快捷键和跨脚本通信
├── popup.html/js          # 扩展弹窗界面，控制滚动功能
├── grok_content.js        # Grok网站界面优化
├── grok_insert_text.js    # Grok快捷键文本插入
├── pinterest_content.js   # Pinterest图片处理
├── gemini_auto_save.js    # Google AI Studio自动保存
├── medium_content.js      # Medium菜单隐藏
├── scroll_control.js      # 通用滚动控制
└── images/               # 扩展图标资源
```

### 技术特点

- **Manifest V3 规范**：使用最新的 Chrome 扩展 API
- **内容脚本注入**：针对特定网站注入相应功能脚本
- **消息传递机制**：background.js 与内容脚本间的通信
- **会话存储**：使用 sessionStorage 保持状态持久化
- **DOM 监控**：MutationObserver 监控页面动态变化
- **平滑动画**：使用 requestAnimationFrame 实现流畅滚动效果
- **错误处理**：完善的错误捕获和日志记录机制

### 权限管理

- `storage`：存储用户设置和状态
- `activeTab`：访问当前活动标签页
- `scripting`：注入内容脚本
- `downloads`：触发图片下载
- `tabs`：标签页操作
- `clipboardWrite`：剪贴板写入（预留）

## 项目优势

### 1. **针对性强**

- 专门为 AI 工具网站设计，解决实际使用痛点
- 每个功能都针对特定场景优化

### 2. **用户体验优秀**

- 自动化繁琐操作，提升使用效率
- 无侵入式设计，不影响原有功能
- 智能状态管理，用户无需重复设置

### 3. **技术实现成熟**

- 使用现代 Chrome 扩展 API
- 完善的错误处理和日志系统
- 良好的代码组织和模块化设计

### 4. **扩展性良好**

- 模块化架构，易于添加新网站支持
- 统一的消息传递机制
- 清晰的文件组织结构

## 使用场景

### 开发者场景

- 在 Grok 上快速获得中文编程解答
- 在 Google AI Studio 中安全编辑长 Prompt
- 高效浏览技术文章和文档

### 内容创作者场景

- 快速收集 Pinterest 高质量原图
- 清洁的 Medium 阅读体验
- 自动化的内容浏览和收集

### 研究学习场景

- 自动滚动浏览大量内容
- 专注的 AI 对话体验
- 高效的资料收集和整理

## 项目特色

### 智能化

- 自动检测页面状态和元素
- 智能的错误恢复机制
- 自适应的功能启用/禁用

### 人性化

- 符合用户习惯的交互设计
- 清晰的状态反馈
- 最小化的学习成本

### 稳定性

- 多重保障机制
- 完善的异常处理
- 兼容性检查和适配

这个项目展现了如何为特定网站创建定制化的浏览器扩展，每个功能都针对具体的使用场景和用户需求，体现了深度的用户体验思考和技术实现能力。


目录: images
内容: [这是一个目录]

完整的路径: D:\JS\chrome_extension\aiTools\images\g1.png
内容: [无法作为文本读取，可能是二进制文件]

完整的路径: D:\JS\chrome_extension\aiTools\images\g2.png
内容: [无法作为文本读取，可能是二进制文件]

完整的路径: D:\JS\chrome_extension\aiTools\images\icon128.png
内容: [无法作为文本读取，可能是二进制文件]

完整的路径: D:\JS\chrome_extension\aiTools\images\icon128_active.png
内容: [无法作为文本读取，可能是二进制文件]

完整的路径: D:\JS\chrome_extension\aiTools\images\icon16.png
内容: [无法作为文本读取，可能是二进制文件]

完整的路径: D:\JS\chrome_extension\aiTools\images\icon16_active.png
内容: [无法作为文本读取，可能是二进制文件]

完整的路径: D:\JS\chrome_extension\aiTools\images\icon48.png
内容: [无法作为文本读取，可能是二进制文件]

完整的路径: D:\JS\chrome_extension\aiTools\images\icon48_active.png
内容: [无法作为文本读取，可能是二进制文件]
